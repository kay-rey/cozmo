---
alwaysApply: true
---

# Cozmo Discord Bot - Development Rules

## üéØ Project Overview

Cozmo is a Discord bot for LA Galaxy fans providing match info, stats, news, and trivia. It's designed to run in a Docker container on a Raspberry Pi 2, following DRY principles and modern Python practices. The project uses **UV** as the package manager for fast, reliable dependency management.

## üèóÔ∏è Architecture & Code Organization

### DRY Principles (Don't Repeat Yourself)

- **Extract common functionality** into utility functions in `utils/`
- **Reuse database operations** through centralized database manager
- **Share API clients** across cogs to avoid duplicate HTTP sessions
- **Consolidate error handling** in base classes and decorators
- **Create reusable embed templates** for consistent UI
- **Abstract configuration** through centralized config management

### File Structure Rules

```
cozmo/
‚îú‚îÄ‚îÄ main.py                 # Bot entry point only
‚îú‚îÄ‚îÄ config.py              # Centralized configuration
‚îú‚îÄ‚îÄ health_server.py       # Health monitoring for deployment
‚îú‚îÄ‚îÄ api/                   # External API integrations
‚îú‚îÄ‚îÄ cogs/                  # Discord command modules
‚îú‚îÄ‚îÄ utils/                 # Shared utilities and core logic
‚îú‚îÄ‚îÄ data/                  # Static data and database files
‚îú‚îÄ‚îÄ tests/                 # Test suite
‚îú‚îÄ‚îÄ docs/                  # Documentation
‚îú‚îÄ‚îÄ scripts/               # Utility scripts
‚îî‚îÄ‚îÄ logs/                  # Runtime logs
```

### Module Organization

- **One responsibility per module** - each file should have a single, clear purpose
- **Cogs for Discord commands** - all Discord interactions go in `cogs/`
- **Utils for business logic** - core functionality in `utils/`
- **API for external services** - all external API calls in `api/`
- **No circular imports** - maintain clear dependency hierarchy

## üê≥ Docker & Raspberry Pi 2 Optimization

### Resource Constraints

- **Memory efficient** - minimize memory usage for Pi 2's limited RAM
- **CPU optimized** - avoid blocking operations, use async/await
- **Disk space conscious** - clean up logs and temporary files
- **Network efficient** - cache API responses, minimize external calls

### Docker Best Practices

- **Multi-stage builds** - separate build and runtime environments
- **Python 3.9 slim base** - use `python:3.9-slim-bullseye` for optimal Pi 2 compatibility
- **Health checks** - implement proper health monitoring
- **Graceful shutdown** - handle SIGTERM signals properly
- **Volume mounts** - persist database and logs outside container

### Performance Guidelines

- **Async operations** - use `async`/`await` for all I/O operations
- **Connection pooling** - reuse HTTP connections
- **Lazy loading** - load cogs and data only when needed
- **Memory monitoring** - track memory usage and clean up resources
- **Rate limiting** - respect API limits and implement backoff strategies

## üêç Python Code Standards

### Code Style

- **Follow PEP 8** - use Black formatter for consistency
- **Type hints** - use type annotations for all function parameters and returns
- **Docstrings** - document all public functions and classes
- **Error handling** - use specific exception types, not bare `except:`
- **Logging** - use structured logging with appropriate levels

### UV Package Manager

- **Use UV for all dependencies** - never use pip directly
- **Lock file management** - always commit `uv.lock` for reproducible builds
- **Dependency updates** - use `uv lock --upgrade` to update dependencies
- **Virtual environment** - UV manages virtual environments automatically
- **Project configuration** - use `pyproject.toml` for project settings
- **Installation commands** - use `uv add <package>` for new dependencies
- **Running scripts** - use `uv run python script.py` for execution

### Async Programming

- **Always use async/await** for I/O operations
- **Use asyncio.gather()** for concurrent operations
- **Proper exception handling** in async functions
- **Resource cleanup** in finally blocks or context managers
- **Avoid blocking operations** in async functions

### Database Operations

- **Use aiosqlite** for async database operations
- **Connection pooling** - reuse database connections
- **Transaction management** - use proper transaction boundaries
- **Error handling** - handle database errors gracefully
- **Migrations** - version control database schema changes

## üß™ Testing & Quality Assurance

### Test Structure

- **Unit tests** - test individual functions and methods
- **Integration tests** - test component interactions
- **End-to-end tests** - test complete user workflows
- **Mock external APIs** - don't make real API calls in tests
- **Test data isolation** - use separate test database

### Test Coverage

- **Minimum 80% coverage** for core functionality
- **Test error conditions** - ensure proper error handling
- **Test edge cases** - handle boundary conditions
- **Test async code** - use pytest-asyncio for async tests
- **Test database operations** - verify data integrity

### Quality Gates

- **All tests must pass** before merging
- **No linting errors** - use flake8 or similar
- **Type checking** - use mypy for static type checking
- **Security scanning** - check for vulnerabilities
- **Performance testing** - ensure acceptable response times

## üîí Security & Best Practices

### Environment Variables

- **Never commit secrets** - use `.env` files and environment variables
- **Validate configuration** - check required variables at startup
- **Use secure defaults** - fail safely when configuration is missing
- **Rotate secrets** - implement secret rotation strategies
- **Environment separation** - different configs for dev/staging/prod

### API Security

- **Rate limiting** - implement proper rate limiting
- **Input validation** - validate all user inputs
- **SQL injection prevention** - use parameterized queries
- **XSS prevention** - sanitize user-generated content
- **CSRF protection** - validate request origins

### Discord Bot Security

- **Minimal permissions** - only request necessary Discord permissions
- **User input sanitization** - clean all user-provided data
- **Command validation** - validate command parameters
- **Error message sanitization** - don't expose internal details
- **Audit logging** - log security-relevant events

### Discord API & Documentation

- **Always refer to official docs** - use [Discord Developer Portal](https://discord.com/developers/docs) as the primary source
- **Follow Discord.py documentation** - reference [discord.py documentation](https://discordpy.readthedocs.io/) for implementation details
- **Stay updated** - Discord API changes frequently, always check for breaking changes
- **Use official examples** - prefer Discord's official code examples over third-party tutorials
- **API versioning** - be aware of Discord API version changes and deprecations
- **Rate limiting** - follow Discord's rate limit guidelines from official documentation

## üìù Documentation Standards

### Code Documentation

- **Docstrings** - document all public functions, classes, and methods
- **Type hints** - use type annotations for better IDE support
- **Comments** - explain complex logic and business rules
- **README updates** - keep README current with new features
- **API documentation** - document external API integrations

### Commit Documentation

- **Conventional commits** - use standardized commit message format
- **Clear descriptions** - explain what and why, not just what
- **Reference issues** - link to GitHub issues when applicable
- **Breaking changes** - clearly mark breaking changes
- **Scope indicators** - specify which component is affected

## üöÄ Deployment & Operations

### Docker Configuration

- **Multi-stage builds** - optimize image size
- **Health checks** - implement proper health monitoring
- **Resource limits** - set appropriate memory and CPU limits
- **Volume mounts** - persist data outside container
- **Environment variables** - use env files for configuration

### Monitoring & Logging

- **Structured logging** - use JSON format for logs
- **Log levels** - appropriate use of DEBUG, INFO, WARNING, ERROR
- **Health endpoints** - implement health check endpoints
- **Metrics collection** - track performance metrics
- **Error alerting** - notify on critical errors

### Backup & Recovery

- **Database backups** - regular automated backups
- **Configuration backups** - version control configuration
- **Disaster recovery** - documented recovery procedures
- **Data migration** - safe database migration strategies
- **Rollback procedures** - ability to rollback deployments

## Commit Style Guidelines

### Conventional Commits Format

Always use conventional commits with the following structure:

**Title Format:**

```
<type>[optional scope]: <description>
```

**Description Format:**

```
[body]

[optional footer(s)]
```

### Commit Types

- `feat`: A new feature
- `fix`: A bug fix
- `docs`: Documentation only changes
- `style`: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
- `refactor`: A code change that neither fixes a bug nor adds a feature
- `perf`: A code change that improves performance
- `test`: Adding missing tests or correcting existing tests
- `chore`: Changes to the build process or auxiliary tools and libraries
- `ci`: Changes to CI configuration files and scripts
- `build`: Changes that affect the build system or external dependencies
- `revert`: Reverts a previous commit

### Examples

**Title:**

```
feat(pokemon): add shiny pokemon detection
```

**Description:**

```
Add functionality to detect and display shiny Pokemon variants in the card search results. This includes updating the Pokemon data model to include shiny status and modifying the search algorithm to highlight shiny cards.

- Added shiny field to Pokemon data structure
- Updated search results display to show shiny indicator
- Added tests for shiny detection logic

Closes #123
```

**Title:**

```
fix(bot): resolve command timeout issues
```

**Description:**

```
Fix timeout errors that occur when Discord commands take longer than 3 seconds to process. Implemented async command handling and added proper error handling for long-running operations.

- Added async/await pattern for command execution
- Implemented timeout handling with proper error messages
- Added logging for command execution times

Fixes #456
```

**Title:**

```
docs: update setup instructions for new dependencies
```

**Description:**

```
Update README.md with installation instructions for the new uv package manager and updated Python version requirements.

- Added uv installation steps
- Updated Python version requirement to 3.11+
- Added troubleshooting section for common setup issues
```

### Important Notes

- Keep the title under 50 characters
- Use lowercase for the type and scope
- Don't end the title with a period
- Use the imperative mood ("add feature" not "added feature")
- Provide the commit text in a format ready for copy-paste
- Separate title and description clearly for easy copying

## üö® Error Handling & Recovery

### Error Categories

- **User errors** - invalid input, missing permissions
- **API errors** - external service failures
- **System errors** - database, network, configuration issues
- **Discord errors** - rate limits, permission issues

### Error Handling Strategy

- **Graceful degradation** - continue operation when possible
- **User-friendly messages** - clear error messages for users
- **Detailed logging** - comprehensive error logging for debugging
- **Retry mechanisms** - automatic retry for transient failures
- **Circuit breakers** - prevent cascade failures

### Recovery Procedures

- **Automatic recovery** - self-healing mechanisms
- **Manual intervention** - documented recovery procedures
- **Monitoring alerts** - notify on critical errors
- **Rollback procedures** - quick rollback for critical issues
- **Post-mortem analysis** - learn from failures

## üìä Performance & Optimization

### Performance Targets

- **Response time** - < 2 seconds for most commands
- **Memory usage** - < 512MB on Raspberry Pi 2
- **CPU usage** - < 50% average load
- **Database queries** - < 100ms for simple queries
- **API calls** - < 5 seconds timeout

### Optimization Strategies

- **Caching** - cache frequently accessed data
- **Connection pooling** - reuse database and HTTP connections
- **Lazy loading** - load data only when needed
- **Batch operations** - group related operations
- **Async operations** - use async/await for I/O

### Monitoring

- **Performance metrics** - track response times and resource usage
- **Error rates** - monitor error frequency and types
- **User activity** - track command usage and patterns
- **System health** - monitor memory, CPU, and disk usage
- **API health** - monitor external service availability

## üîß Development Workflow

### Local Development

1. **Create feature branch** from main
2. **Make changes** following coding standards
3. **Write tests** for new functionality
4. **Run tests** and ensure they pass
5. **Update documentation** if needed
6. **Create pull request** with clear description
7. **Code review** and address feedback
8. **Merge** after approval

### Testing Workflow

1. **Unit tests** - test individual components
2. **Integration tests** - test component interactions
3. **End-to-end tests** - test complete workflows
4. **Performance tests** - ensure acceptable performance
5. **Security tests** - check for vulnerabilities
6. **Manual testing** - verify user experience

### Deployment Workflow

1. **Build Docker image** with latest changes
2. **Test in staging** environment
3. **Deploy to production** with health checks
4. **Monitor deployment** for issues
5. **Rollback if needed** using documented procedures
6. **Post-deployment verification** - confirm functionality

## üéØ Feature Development Guidelines

### New Feature Checklist

- [ ] **Requirements analysis** - understand the problem
- [ ] **Design review** - plan the implementation
- [ ] **Code implementation** - follow coding standards
- [ ] **Test coverage** - write comprehensive tests
- [ ] **Documentation** - update relevant docs
- [ ] **Performance testing** - ensure acceptable performance
- [ ] **Security review** - check for vulnerabilities
- [ ] **User testing** - verify user experience
- [ ] **Deployment** - deploy to production
- [ ] **Monitoring** - track feature usage and performance

### Code Review Checklist

- [ ] **Functionality** - does it work as expected?
- [ ] **Code quality** - follows coding standards
- [ ] **Performance** - efficient implementation
- [ ] **Security** - no security vulnerabilities
- [ ] **Testing** - adequate test coverage
- [ ] **Documentation** - clear and complete
- [ ] **Error handling** - proper error management
- [ ] **Logging** - appropriate logging levels
- [ ] **Configuration** - uses config system properly
- [ ] **Dependencies** - no unnecessary dependencies

## üöÄ Continuous Improvement

### Regular Reviews

- **Code quality** - monthly code quality reviews
- **Performance** - quarterly performance analysis
- **Security** - regular security assessments
- **Documentation** - keep documentation current
- **Dependencies** - regular dependency updates

### Learning & Growth

- **Stay updated** - follow Python and Discord.py updates
- **Best practices** - adopt new best practices
- **Community feedback** - listen to user feedback
- **Performance optimization** - continuous performance improvements
- **Feature enhancement** - regular feature updates

---

**Remember:** This bot runs on a Raspberry Pi 2 with limited resources. Always consider performance, memory usage, and efficiency in every decision. Follow DRY principles to reduce code duplication and maintain a clean, maintainable codebase.
